\documentclass[aspectratio=169,10pt]{beamer}
\usetheme{Madrid}
\usepackage[T1]{fontenc}

\usepackage{fancybox,graphicx,hyperref,url}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows}
\usetikzlibrary{positioning}
\usepackage{booktabs}
\usepackage{enumitem}

\usepackage{listings}
\usepackage{lstautogobble}
\input{lstisabelle}
\usepackage[listings,skins,breakable,xparse]{tcolorbox}
\tcbuselibrary{theorems}
\tcbset{highlight math/.append style={boxrule=0pt,
                                      frame hidden,
                                      colback=yellow!40!white,
                                      sharp corners}}

\usepackage{xpatch}
\usepackage{xcolor}
\usepackage{realboxes}
\usetikzlibrary{fit}
\usetikzlibrary{shadings}
\usetikzlibrary{shapes.arrows,shadows.blur}

\pgfdeclarefunctionalshading{Hermite-Gaussian modes}{\pgfpoint{-25bp}{-25bp}}{\pgfpoint{25bp}{25bp}}{}{
    10 atan sin 1000 mul cos 1 add
    exch
    10 atan sin 1000 mul cos 1 add
    mul 4 div
    dup dup
}

\makeatletter
\xpretocmd\lstinline{\Colorbox{yellow!10!white}\bgroup\appto\lst@DeInit{\egroup}}{}{}
\makeatother

\definecolor{my_red}{RGB}{128, 0, 0}

\lstset{captionpos=b}
\lstset{numberbychapter=false}
\lstset{autogobble}
% \lstset{breaklines=true}

\usepackage{tikz}
\usepackage{subcaption}
\usetikzlibrary{calc, chains, decorations.pathmorphing}
\usetikzlibrary{shapes,arrows,backgrounds}
\usetikzlibrary{positioning,fit,shapes.geometric,shapes}

\setbeamercovered{transparent}

\setlistdepth{9}
\setlist[itemize,1]{label=$\bullet$}
\setlist[itemize,2]{label=$\bullet$}
\setlist[itemize,3]{label=$\bullet$}
\setlist[itemize,4]{label=$\bullet$}
\setlist[itemize,5]{label=$\bullet$}
\setlist[itemize,6]{label=$\bullet$}
\setlist[itemize,7]{label=$\bullet$}
\setlist[itemize,8]{label=$\bullet$}
\setlist[itemize,9]{label=$\bullet$}
\renewlist{itemize}{itemize}{9}

\setlist[enumerate,1]{label=$\arabic*.$}
\setlist[enumerate,2]{label=$\alph*.$}
\setlist[enumerate,3]{label=$\roman*.$}
\setlist[enumerate,4]{label=$\arabic*.$}
\setlist[enumerate,5]{label=$\alpha*$}
\setlist[enumerate,6]{label=$\roman*.$}
\setlist[enumerate,7]{label=$\arabic*.$}
\setlist[enumerate,8]{label=$\alph*.$}
\setlist[enumerate,9]{label=$\roman*.$}
\renewlist{enumerate}{enumerate}{9}

\AtBeginSection[]{
  \begin{frame}[noframenumbering]
    \vfill
    \centering
    \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
      \usebeamerfont{title}\insertsectionhead\par%
    \end{beamercolorbox}
    \vfill
  \end{frame}
}

\title[Efficient and Verified Non-Terminating Programs with Isabelle-LLVM]{Efficient and Verified Non-Terminating Programs with Isabelle-LLVM}

\author[Rafael Castro]{
  Rafael Castro G. Silva\\\medskip
  {\small \url{rasi@di.ku.dk}}}

\date{23/11/2023}

\institute[UCPH]{
  Department of Computer Science \\
  University of Copenhagen}

\begin{document}
\setbeamercovered{invisible}
% \setbeamercovered{dynamic}

\begin{frame}
  \titlepage

\end{frame}

\section{Introduction}

\begin{frame}[fragile]
  \frametitle{Context}
  \begin{itemize}
          \pause
    \item Distributed Systems
          \begin{itemize}
            \item Stream processing frameworks
                  \begin{itemize}
                    \item Dataflow models
                          \begin{itemize}
                            \item Time-Aware Computations
                          \end{itemize}
                  \end{itemize}
          \end{itemize}
          \pause
    \item Formal Methods
          \begin{itemize}
            \item Verification using proof assistants
                  \begin{itemize}
                    \item Isabelle proofs
                          \begin{itemize}
                            \item Verified + executable + efficient code
                          \end{itemize}
                  \end{itemize}
          \end{itemize}
    \item Formalization of Time-Aware Stream Processing
  \end{itemize}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Stream Processing}
  \begin{itemize}
    \item Stream Processing: Abstraction for processing data when the input is not completely presented in the begging of the computation
          \pause
    \item Dataflow Model:
          \begin{itemize}
            \item Directed graph of interconnected operators that perform event-wise transformations
            \item E.g.: Apache Flink, Apache Samza, Apache Spark, Google Cloud Dataflow, and Timely Dataflow
                  \vspace*{-1ex}
                  \begin{overlayarea}{\textwidth}{.15\textheight}
                    \centering
                    \begin{figure}
                      \centering
                      \only<2->{\includegraphics[scale=0.15]{all.png}}
                    \end{figure}
                  \end{overlayarea}
                  \vspace*{-1ex}
            \item Highly Parallel
                  \vspace*{-1ex}
                  \begin{figure}
                    \begin{subfigure}{0.45\linewidth}
                      \begin{tikzpicture}[node distance = 0.6cm, scale=0.6, transform shape]]
                        \tikzstyle{operator} = [rectangle, draw, fill=blue!60, text width=3.0em, text centered, minimum height=20pt, line width=1pt]

                        \node [operator] at (0,0)  (concat) {concat};
                        \node [operator, right = of concat] (map) {map};
                        \node [operator, right = of map] (filter) {filter};
                        \node [operator, right = of filter] (count) {count};

                        \draw[<-,thick,shorten >=1pt] ([yshift=5pt]concat.west)  -- node[above]{} ++(-2em,0em);
                        \draw[<-,thick,shorten >=1pt] ([yshift=-5pt]concat.west)  -- node[above]{} ++(-2em,0em);
                        \draw [thick,->,shorten >=1pt] (concat) -- (map);
                        \draw [thick,->,shorten >=1pt] (map) -- (filter);
                        \draw [thick,->,shorten >=1pt] (filter) -- (count);
                        \draw[->,thick,shorten >=1pt] (count.east)  -- node[above]{} ++(2em,0em);

                        \node[draw,densely dotted, label={[xshift=2mm]above:{\tiny logical dataflow}},fit=(concat) (map) (filter) (count)] {};

                      \end{tikzpicture}
                    \end{subfigure}
                    \begin{subfigure}{0.45\linewidth}
                      \begin{tikzpicture}[node distance = 0.6cm,auto, scale=0.6, transform shape]]
                        \tikzstyle{operator} = [rectangle, draw, fill=blue!60, text width=3.0em, text centered, minimum height=20pt, line width=1pt]

                        \node [operator] at (0,0)  (concat) {concat};
                        \node [operator, right = of concat] (map) {map};
                        \node [operator, right = of map] (filter) {filter};
                        \node [operator, right = of filter] (count) {count};

                        \draw[<-,thick,shorten >=1pt] ([yshift=5pt]concat.west)  -- node[above]{} ++(-2em,0em);
                        \draw[<-,thick,shorten >=1pt] ([yshift=-5pt]concat.west)  -- node[above]{} ++(-2em,0em);
                        \draw [thick,->,shorten >=1pt] (concat) -- (map);
                        \draw [thick,->,shorten >=1pt] (map) -- (filter);
                        \draw [thick,->,shorten >=1pt] (filter) -- (count);
                        \draw[->,thick,shorten >=1pt] (count.east)  -- node[above]{} ++(2em,0em);

                        \node[draw,densely dotted, label={[xshift=2mm]above:{\tiny worker 1}},fit=(concat) (map) (filter) (count)] {};

                        \node [operator, below=0.7cm of concat]  (concat') {concat};
                        \node [operator, right = of concat'] (map') {map};
                        \node [operator, right = of map'] (filter') {filter};
                        \node [operator, right = of filter'] (count') {count};

                        \draw[<-,thick,shorten >=1pt] ([yshift=5pt]concat'.west)  -- node[above]{} ++(-2em,0em);
                        \draw[<-,thick,shorten >=1pt] ([yshift=-5pt]concat'.west)  -- node[above]{} ++(-2em,0em);
                        \draw [thick,->,shorten >=1pt] (concat') -- (map');
                        \draw [thick,->,shorten >=1pt] (map') -- (filter');
                        \draw [thick,->,shorten >=1pt] (filter') -- (count');
                        \draw[->,thick,shorten >=1pt] (count'.east)  -- node[above]{} ++(2em,0em);

                        \node[draw,densely dotted, label={[xshift=2mm]above:{\tiny worker 1}},fit=(concat) (map) (filter) (count)] {};
                        \node[draw,densely dotted, label={[xshift=2mm]above:{\tiny worker 2}},fit=(concat') (map') (filter') (count')] {};
                        \node[draw,dotted, label={[xshift=2mm, yshift=0.3cm]above:{\tiny physical workers}},fit=(concat') (concat) (map') (map) (filter) (filter') (count) (count')] {};
                      \end{tikzpicture}
                    \end{subfigure}
                  \end{figure}
          \end{itemize}
                  \vspace*{-1ex}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Time-Aware Stream Processing}
  \begin{itemize}
    \item Time-Aware Computations:
          \begin{itemize}
            \item Timestamps: Metadata associating the data with some data collection
                  \begin{itemize}
                    \item An unix timestamp
                    \item Version of the data
                    \item Logical grouping
                  \end{itemize}
            \item Watermarks: Metadata indicating the completion of a data collection
                  \begin{itemize}
                    \item e.g.: A watermark 5 says that there is no data associated with timestamp 5 or bellow arriving
                    \item Are increasingly monotonic (they don't go backwards in time)
                  \end{itemize}
            \item e.g.:
  \begin{figure}[!t]
      \raggedright
        \begin{tikzpicture}[scale=0.8, every node/.style={scale=0.8},background rectangle/.style={fill=yellow!10!white},show background rectangle]
          \tikzset{tape/.style={minimum size=.6cm, draw}}
          \begin{scope}[start chain=0 going right, node distance=0mm]
            \foreach \x [count=\i] in {\is{DT t_4 **d**},\is{DT t_0 **a**},\is{DT t_1 **c**},\is{WM t_1},\is{DT t_2 **b**}, \is{WM t_2},\is{DT t_5 **c**},\is{DT t_3 **a**},\is{DT t_5 **a**},\is{WM t_5}} {
                \node [on chain=0, tape] (n\i) {\x};
            }
            \node [right=.05cm of n10] {$\cdots$};
          \end{scope}
        \end{tikzpicture}
    \end{figure}
          \end{itemize}
  \end{itemize}
\end{frame}

\section{Preliminaries}
\begin{frame}[fragile]
  \frametitle{Isabelle/HOL}
  \begin{itemize}
    \item Classical higher-order logic (HOL): Simple Typed Lambda Calculus + (Hilbert) axiom of choice + axiom of infinity + rank-1 polymorphism
          \pause
    \item Isabelle: A generic proof assistant
          \begin{overlayarea}{\textwidth}{.45\textheight}
            \centering
            \begin{figure}
              \centering
              \only<2>{\includegraphics[scale=0.15]{isabelle}}
            \end{figure}
          \end{overlayarea}
    \item Isabelle/HOL: Isabelle's flavor of HOL
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Isabelle/HOL: (Co)datatypes}
  \begin{itemize}
    \item Datatypes and Codatatypes
\vspace*{-1ex}
          \begin{tcblisting}{hbox,listing only,listing options={language=isabelle,aboveskip=0pt,belowskip=0pt},size=fbox,boxrule=0pt,frame hidden,arc=0pt,colback=yellow!10!white}
codatatype (lset: 'a) llist = lnull: LNil | LCons (lhd: 'a) (ltl: "'a llist")
  for map: lmap where "ltl LNil = LNil"
          \end{tcblisting}
\vspace*{-1ex}
    \item Examples:
          \begin{itemize}
            \item \is{LNil}
            \item \is{LCons 1 (LCons 2 (LCons 3 LNil))}
            \item \is{LCons 0 (LCons 0 (LCons 0 (...)))}
          \end{itemize}
\vspace*{-1ex}
    \item Proofs by induction
    \item Proofs by coinduction
  \end{itemize}
\end{frame}

\section{State of this work}

\begin{frame}[fragile]
  \frametitle{What have I formalized so far? (part 1)}
  \begin{itemize}
    \item Formalization stream processing (model)
          \begin{itemize}
            \item Using Isabelle/HOL: (co)datatypes, (co)recursion, and (co)induction
            \item Streams are lazy lists, and operators as a codatatype
            \item Semantics: a \is{produce} function that runs an operator throughout a lazy lists
                  \begin{itemize}
                    \item Mix of recursion and corecursion: inductive and coinductive principles
                  \end{itemize}
            \item Sequential composition
                  \begin{itemize}
                    \item Correctness!
                  \end{itemize}
          \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{What have I formalized so far?  (part 2)}
  \begin{itemize}
    \item Time-Aware computations
          \begin{itemize}
            \item Coinductive properties of streams: monotonicity and productivity
            \item Building blocks operators:
                  \begin{itemize}
                    \item Convenience operators: batching and incremental computations
                          \begin{itemize}
                            \item Incremental computing: only update results that are affected by the new input
                            \item With verified properties: Soundness, Completeness, preservation of productivity, and preservation of monotonicity
                          \end{itemize}
                  \end{itemize}
            \item Compositional reasoning
          \end{itemize}
    \item Case studies with the building blocks:
          \begin{itemize}
            \item Incremental histogram operator
            \item Relational join
          \end{itemize}
  \end{itemize}
\end{frame}

\section{Next Steps}

\begin{frame}[fragile]
  \frametitle{Efficient Stream Processing}
  \begin{itemize}
    \item It is executable! But slow!
          \begin{itemize}
            \item Code generator: functional languages (OCaml, Haskell, SML...)
            \item Functional data-structures (often not ideal)
          \end{itemize}
    \pause
    \item How do we make efficient and verified programs in Isabelle/HOL?
          \pause
          \item Isabelle-LLVM!
          \item Let's port this formalization to Isabelle-LLVM then!
    \item This is a non-terminating program
    \end{itemize}
\end{frame}

\section{Isabelle-LLVM}

\begin{frame}[fragile]
  \frametitle{Isabelle Refinement Framework and Isabelle-LLVM}
  \begin{itemize}
    \item Isabelle Refinement Framework
          \begin{itemize}
            \item Framework for step-wise refinement verification (refinement calculus): Specification $\rightarrow$ Abstract Algorithm $\rightarrow$ Less Abstract Algorithm $\rightarrow$ Executable Code
            \item Imperative HOL as backend (lowest layer in the refinement)
                  \begin{itemize}
                    \item Shallow Embedding of Monadic programs in HOL
                  \end{itemize}
            \item Separation Logic (heap memory reasoning)
          \end{itemize}
    \item Isabelle-LLVM is a new backend for the Isabelle Refinement Framework
          \begin{itemize}
            \item Generates LLVM code (efficient imperative code)
          \end{itemize}
          \pause
    \item Can we write and verify non-terminating programs in this framework?
          \pause
          \begin{itemize}
            \item Yes and No!
          \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Isabelle-LLVM's Recursion Model}
  \begin{itemize}
    \item Knaster–Tarski theorem
          \begin{itemize}
            \item Standard way to define the semantics of recursive definitions
                  \begin{itemize}
                    \item Isabelle/HOL: Partial Function Package
                  \end{itemize}
            \item Every monotonic function on Complete Chain Partial Order (CCPO) has a fixed point
            \item Induction principle
          \end{itemize}
    \item No need for well-foundness
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{What the Heck is a CCPO?}
  \begin{itemize}
    \item Chain: A set in which all elements are comparable
    \item Complete Chain Partial Order:
          \begin{enumerate}
            \item A partial order: \is{'a::order}
            \item A function that returns the suprimium (least upper bound) from a chain \is{'a::order set => 'a}
          \end{enumerate}
    \pause
    \item Isabelle-LLVM's monad:
          \vspace*{-1ex}
          \begin{tcblisting}{hbox,listing only,listing options={language=isabelle,aboveskip=0pt,belowskip=0pt},size=fbox,boxrule=0pt,frame hidden,arc=0pt,colback=yellow!10!white}
datatype 'a neM = SPEC (the_spec: "'a => bool") | FAIL
          \end{tcblisting}
          \vspace*{-1ex}
          \begin{itemize}
            \item Order: flat (every \is{SPEC} is greater than \is{FAIL}, \is{SPEC}s are only comparable when they are equal)
            \item Suprimium from a chain: The \is{SPEC}, or the only \is{FAIL}
            \item Bottom: \is{FAIL}
                  \begin{itemize}
                    \item Non-termination
                  \end{itemize}
          \end{itemize}
  \end{itemize}
\end{frame}

\section{The First Steps}

\begin{frame}[fragile]
  \frametitle{Our CCPO Attempt}
  \begin{itemize}
    \item Let's look in Isabelle!
  \end{itemize}
\end{frame}

\section{The Other Steps}
\begin{frame}[fragile]
  \frametitle{More Changes to Isabelle-LLVM?}
  \begin{itemize}
    \item Separation Logic?
          \begin{itemize}
            \item Express properties about the trace of the program
          \end{itemize}
    \item Refinement Calculus?
    \item LLVM code generator?
  \end{itemize}
\end{frame}

\section{Questions, comments and suggestions}

\end{document}
