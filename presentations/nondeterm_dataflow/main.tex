\documentclass[aspectratio=169,10pt]{beamer}
\usetheme{Madrid}
\usepackage[T1]{fontenc}

\usepackage{fancybox,graphicx,hyperref,url}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows}
\usetikzlibrary{positioning}
\usepackage{booktabs}
\usepackage{enumitem}

\usepackage{listings}
\usepackage{pdfpages}
\usepackage{lstautogobble}

\usepackage[listings,skins,breakable,xparse]{tcolorbox}
\tcbuselibrary{theorems}
\tcbset{highlight math/.append style={boxrule=0pt,
                                      frame hidden,
                                      colback=yellow!40!white,
                                      sharp corners}}

\usepackage{xpatch}
\usepackage{xcolor}
\usepackage{realboxes}
\usetikzlibrary{fit}
\usetikzlibrary{shadings}
\usetikzlibrary{shapes.arrows,shadows.blur}

\pgfdeclarefunctionalshading{Hermite-Gaussian modes}{\pgfpoint{-25bp}{-25bp}}{\pgfpoint{25bp}{25bp}}{}{
    10 atan sin 1000 mul cos 1 add
    exch
    10 atan sin 1000 mul cos 1 add
    mul 4 div
    dup dup
}

\makeatletter
\xpretocmd\lstinline{\Colorbox{yellow!10!white}\bgroup\appto\lst@DeInit{\egroup}}{}{}
\makeatother

\definecolor{my_red}{RGB}{128, 0, 0}

\lstset{captionpos=b}
\lstset{numberbychapter=false}
\lstset{autogobble}
% \lstset{breaklines=true}

\usepackage{tikz}
\usepackage{subcaption}
\usetikzlibrary{calc, chains, decorations.pathmorphing}
\usetikzlibrary{shapes,arrows,backgrounds}
\usetikzlibrary{positioning,fit,shapes.geometric,shapes}

\setbeamercovered{transparent}

\setlistdepth{9}
\setlist[itemize,1]{label=$\bullet$}
\setlist[itemize,2]{label=$\bullet$}
\setlist[itemize,3]{label=$\bullet$}
\setlist[itemize,4]{label=$\bullet$}
\setlist[itemize,5]{label=$\bullet$}
\setlist[itemize,6]{label=$\bullet$}
\setlist[itemize,7]{label=$\bullet$}
\setlist[itemize,8]{label=$\bullet$}
\setlist[itemize,9]{label=$\bullet$}
\renewlist{itemize}{itemize}{9}

\setlist[enumerate,1]{label=$\arabic*.$}
\setlist[enumerate,2]{label=$\alph*.$}
\setlist[enumerate,3]{label=$\roman*.$}
\setlist[enumerate,4]{label=$\arabic*.$}
\setlist[enumerate,5]{label=$\alpha*$}
\setlist[enumerate,6]{label=$\roman*.$}
\setlist[enumerate,7]{label=$\arabic*.$}
\setlist[enumerate,8]{label=$\alph*.$}
\setlist[enumerate,9]{label=$\roman*.$}
\renewlist{enumerate}{enumerate}{9}

\AtBeginSection[]{
  \begin{frame}[noframenumbering]
    \vfill
    \centering
    \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
      \usebeamerfont{title}\insertsectionhead\par%
    \end{beamercolorbox}
    \vfill
  \end{frame}
}

\title[Nondeterministic Asynchronous Dataflow in Isabelle/HOL]{Nondeterministic Asynchronous Dataflow in Isabelle/HOL}

\author[Rafael Castro, Laouen Fernet and Dmitriy Traytel]{
  Rafael Castro G. Silva, Laouen Fernet and  Dmitriy Traytel\\\medskip
  {\small \url{rasi@di.ku.dk}}}

\date{14/05/2025}

% change title (done)
% (co)datatypes -> codatatypes (done)
% while_option from HOL library (done)
% coindtive principle -> coinduction principle (done)
% remove next step slide, andd as a bullet (done)
% explain slice in more detail (done)
% mention selectors in llist slide, drop lmap, drop lset (done)
% move count operator example to slide that introduce op type (done)
% modeling lazy list processors which do not care about time (done)
% reduce Corecursion is like recursion line (done)
% why partial order? mention timely dataflow (done)
% explain what incremental, and set expectation for example (done)
% move arrows (done)
% Change push to out, done to out (done)
% put star footnote on op type saying it is simplified compare to the paper, also in the composition lemma (done)
% write the lapp lemma about lfinite (done)
% show coinduction principle for llist (done)
% add link llist afp (done)
% on produce slide, metion lshift as friend (point to freinds with benefits paper) (done)
% justify the compositional reasoning with lines of code for each building block (done)
% slide about tecnicques used, coinduction principles, friends, reasoning up to friends, generalization using skip_op, combining coinduction and induction, coinduction up to congruence for coinductive predicates, say our paper is more detailed in these topics
%
% add definition of batch_op, and all 4 properties

\institute[UCPH]{
  Department of Computer Science \\
  University of Copenhagen}

\begin{document}
\setbeamercovered{invisible}
% \setbeamercovered{dynamic}

\begin{frame}
  \titlepage

\end{frame}
\section{Introduction}

\begin{frame}[fragile]
  \frametitle{Introduction}
  \begin{itemize}
    \item Nondeterministic Asynchronous Dataflow: Directed graph of interconnected operators that perform event-wise transformations
          \begin{itemize}
            \item Dataflow: Directed graph of interconnected operators that perform event-wise transformations
            \item Asynchronous:
                  \begin{itemize}
                    \item Operators execute independently (processes without an orchestrator)
                    \item Operators can communicate with the network (read/write); do silent computation steps
                    \item Networks are unbounded FIFO queues
                  \end{itemize}
            \item Nondeterministic: Operators can make nondeterministic choices
          \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The Process Algebra Model}
  \begin{itemize}
    \item Nondeterministic Asynchronous Dataflow defined as an algebra by Bergstra et al.:
          \begin{figure}
            \centering
            \shadowbox{\includegraphics[width=0.3\textwidth]{Bergstra.png}}
          \end{figure}
    \item Provides a process algebra model (a process calculi) of Nondeterministic Asynchronous Dataflow
    \item Defined basic primitives: sequential and parallel composition; feedback loop
    \item Defined basic primitives: sequential and parallel composition; feedback loop
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Motivation}
  \begin{itemize}
    \item Stream Processing: programs that compute (possibly) unbounded sequences of data (streams)
    \item E.g.: Apache Flink, Apache Samza, Apache Spark, Google Cloud Dataflow, and Timely Dataflow
          \begin{figure}
            \centering
            \includegraphics[scale=0.1]{all}
          \end{figure}
    \item Why?
          \begin{itemize}
            \item Highly Parallel
            \item Low latency (output as soon as possible)
            \item Incremental computing (re-uses previous computations)
          \end{itemize}
  \end{itemize}
\end{frame}

\section{Isabelle/HOL Preliminaries}

\begin{frame}[fragile]
  \frametitle{Isabelle/HOL}
  \begin{itemize}
    \item Classical higher-order logic (HOL): Simple Typed Lambda Calculus + (Hilbert) axiom of choice + axiom of infinity + rank-1 polymorphism
          \pause
    \item Isabelle: A generic proof assistant
          \begin{overlayarea}{\textwidth}{.45\textheight}
            \centering
            \begin{figure}
              \centering
              \only<2>{\includegraphics[scale=0.15]{isabelle}}
            \end{figure}
          \end{overlayarea}
    \item Isabelle/HOL: Isabelle's flavor of HOL
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Isabelle/HOL: Codatatypes}
  \begin{itemize}
    \item Codatatypes
          \vspace*{-1ex}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Isabelle/HOL: Corecursion}
  \begin{itemize}
    \item Recursion: always eventually reduces an argument
    \item Corecursion: always eventually produces something
          \pause
    \item Corec:
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Isabelle/HOL: (Co)inductive Predicates}
  \begin{itemize}
    \item Inductive predicate
          \begin{itemize}
            \item Finite number of introduction rule applications
          \end{itemize}
%           \begin{tcblisting}{hbox,listing only,listing options={language=isabelle,aboveskip=0pt,belowskip=0pt},size=fbox,boxrule=0pt,frame hidden,arc=0pt,colback=yellow!10!white}
% inductive in_llist :: "'a => 'a llist => bool" where
%   In_llist: "in_llist x (LCons x lxs)"
% | Next_llist: "in_llist x lxs => in_llist x (LCons y lxs)"

% in_llist 2 (LCons 1 (LCons (2 (...))))
%           \end{tcblisting}
          \pause
    \item Coinductive predicate
          \begin{itemize}
            \item Infinite number of introduction rule applications
          \end{itemize}
%           \begin{tcblisting}{hbox,listing only,listing options={language=isabelle,aboveskip=0pt,belowskip=0pt},size=fbox,boxrule=0pt,frame hidden,arc=0pt,colback=yellow!10!white}
% coinductive lprefix :: "'a llist => 'a llist => bool" where
%   LNil_lprefix: "lprefix LNil lys"
% | LCons_lprefix: "lprefix lxs lys => lprefix (LCons x lxs) (LCons x lys)"

% lprefix (LCons 1 (LCons (2 (...)))) (LCons 1 (LCons (2 (...))))
%           \end{tcblisting}
          \pause
    \item Coinduction principle
    % \item But not coinduction up to congruence for free
  \end{itemize}
\end{frame}

\section{Operators as a Codatatype}

\begin{frame}[fragile]
  \frametitle{Operators}
  \begin{itemize}
    \item Codatatypes
          \vspace*{-1ex}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Examples}
  \begin{itemize}
    \item Codatatypes
          \vspace*{-1ex}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Operators Equivalences: Motivation}
  \begin{itemize}
    \item foo
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Operators Equivalences: Strong Bisimilarity}
  \begin{itemize}
    \item foo
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Operators Equivalences: Weak Bisimilarity}
  \begin{itemize}
    \item foo
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Operators Equivalences: Trace Equivalence}
  \begin{itemize}
    \item foo
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Numeral Types for Ports}
  \begin{itemize}
    \item foo
  \end{itemize}
\end{frame}

\section{Asynchronous Dataflow Operators}

\begin{frame}[fragile]
  \frametitle{Buffer Infrastructure}
  \begin{itemize}
    \item foo
  \end{itemize}
\end{frame}

\section{Asynchronous Dataflow Properties}

\section{Conclusion}

\begin{frame}
  \frametitle{Conclusion}
  \begin{itemize}
    \item Isabelle/HOL has a good tool set to formalize and reason about stream processing:
          \begin{itemize}
            \item Codatatypes, coinductive predicates, corecursion with friends, reasoning up to friends (congruence),
                  \begin{itemize}
                    \item Coinduction up to congruence principle is automatically derived for codatatypes (but not for coinductive principles)
                  \end{itemize}
          \end{itemize}
    \item Next step: Feedback loop
  \end{itemize}
\end{frame}
% slide about tecnicques used, coinduction principles, friends, reasoning up to friends, generalization using skip_op, combining coinduction and induction, coinduction up to congruence for coinductive predicates, say our paper is more detailed in these topics

\section{Questions, comments and suggestions}

\end{document}
